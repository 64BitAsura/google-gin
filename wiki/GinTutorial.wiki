#summary Using GIN to create a GWT widget
#labels Featured

This tutorial will show how a simple GWT widget can be constructed with GIN. You should be already familiar with [http://code.google.com/p/google-guice/ Guice] - if not, then please read the [http://code.google.com/p/google-guice/wiki/UserGuide Guice User Guide] for an introductory overview of Guice concepts.

== Introduction ==

In regular Guice, you would use:

{{{
// Does NOT work in GWT code!
MyWidgetMainPanel mainPanel = injector.getInstance(MyWidgetMainPanel.class);
}}}

However, as the comment points out that won't work in GWT:
 * There is no actual class available in the resulting !JavaScript.
 * Guice makes heavy use of reflection, most of which GWT does not emulate.

Fortunately in GWT there is a different idiom for which accomplishes the same purpose.

== Step 1. Inheriting the GIN module ==
{{{
<module>
  ...
  <inherits name="com.google.gwt.inject.Inject"/>
  ...
</module>
}}}

== Step 2. Defining the Ginjector ==
Declare an interface with methods that return the desired types:

{{{
@GinModules(MyWidgetClientModule.class)
public interface MyWidgetGinjector extends Ginjector {
  MyWidgetMainPanel getMainPanel();
}
}}}

Experienced GWT users will notice the similarity to the way GWT image bundles and messages are done: You simply create a method for each object type you want to create, and the an implementation of the interface gets generated for you *at compile time*.

Note that you only need to create injector methods for classes that you would directly access in your top-level initialization code, such as the UI classes to install in your `RootPanel`. You don't need to create injector methods for lower-level classes that will be automatically injected. So for example, if Class `A` uses class `B` which uses class `C`, you only need to create an injector method for `A`, as the other classes `B` and `C` will automatically be injected into `A`.

In other words, injector methods provide a bridge between the Guice and non-Guice world.

== Step 3. Declaration the class bindings ==

The next step is to bind the various classes and providers using a Guice module. The module class looks almost exactly like it would in regular Guice (We use the `GinModule` and `AbstractGinModule` instead of `Module` and `AbstractModule`.) Here's an example module:

{{{
public class MyWidgetClientModule extends AbstractGinModule {
  protected void configure() {
    bind(MyWidgetMainPanel.class).in(Singleton.class);
    bind(MyRemoteService.class).toProvider(MyRemoteServiceProvider.class);
  }
}
}}}

Note that if GIN can't find a binding for a class, it falls back to calling {{{GWT.create()}}} on that class. What this means that image bundles and translated messages will just magically work.

== Step 4. Associating the module with the injector ==

{{{
MyWidgetProject/
    client/
        MyWidget.java
        MyWidgetGinjector.java
        MyWidgetMainPanel.java
        MyWidgetClientModule.java
    public/
    server/
}}}

(TODO: Add build file example)

== Step 5. Creating the Ginjector ==

To create the injector instance, use the standard {{{GWT.create()}}} call. This can be done during static initialization:

{{{
public class MyWidget implements EntryPoint {
  private final MyWidgetGinjector injector = GWT.create(MyWidgetGinjector.class);

  public void onModuleLoad() {
    MyWidgetMainPanel mainPanel = injector.getMainPanel();
    RootPanel.get().add(mainPanel);
  }

}
}}}