#summary Using GIN to create a GWT widget
#labels Featured

= Using GIN to create a GWT widget =

== Step 1. Defining the injector ==

The role of the `Injector` class in GIN is the same as in regular Guice, however the API is a little different. In regular Guice, you would use:

{{{
MyClass myClass = injector.getInstance(MyClass.class);
}}}

However, that won't work in GWT, since there is no actual class available. Fortunately in GWT there is a different idiom for which accomplishes the same purpose, which is to declare an interface with methods that return the desired types:

{{{
@Modules("com.example.mywidget.rebind.MyWidgetClientModule")
public interface MyWidgetInjector extends Injector {
  MyWidgetMainPanel getMainPanel();
}
}}}

   Experienced GWT users will notice the similarity to the way GWT image bundles and messages are done: You simply create a method for each object type you want to create. The name of the method is arbitrary and can be anything you like.

   Note that you only need to create injector methods for classes that you would directly access in your top-level initialization code, such as the UI classes to install in your `RootPanel`. You don't need to create injector methods for lower-level classes that will be automatically injected. So for example, if Class `A` uses class `B` which uses class `C`, you only need to create an injector method for `A`, as the other classes `B` and `C` will automatically be injected into `A`.

   In other words, injector methods provide a bridget between the Guice and non-Guice world.

== Step 2. Declaration the class bindings ==

The next step is to bind the various classes and providers using a Guice module. The module class looks almost exactly like it would in regular Guice (in fact the API classes are the same.) Here's an example module:

{{{
public class MyWidgetClientModule extends AbstractModule {
  protected void configure() {
    bind(MyWidgetMainPanel.class).in(Singleton.class);
    bind(MyRemoveService.class).toProvider(MyRemoteServiceProvider.class);
  }
}
}}}

Note that if GIN can't find a binding for a class, it falls back to calling {{{GWT.create()}}} on that class. What this means that image bundles and translated messages will just magically work.

== Step 3. Associating the module with the injector ==

Although the module class looks exactly like a regular Guice module, the way that it is used to create the injector is very different from regular Guice. You'll need to create a new project directory called "rebind" that sits next to "client", "public", "server" and the other standard GWT folders. The rebind directory contains all of the module sources:

 * MyWidget/
   * client/
     * MyWidget.java
     * MyWidgetInjector.java
     * MyWidgetMainPanel.java
   * rebind/
     * MyWidgetClientModule.java
   * public/
   * server/

The rebind classes should be placed in their own java library.

(TODO: Add build file example)

The rebind library is not added as a dependency of the widget's gwt_module - instead, it is added as a depedency of the gwt application.

(TODO: Add build file example)

Finally, you'll need to add the name of the module to a {{{@Module}}} attribute which is placed on the injector (as seen in the example above.)

== Step 4. Creating the Injector ==

To create the injector instance, use the standard {{{GWT.create()}}} call. This can be done during static initialization:

{{{
public class MyWidget implements EntryPoint {
  private final MyWidgetInjector injector = GWT.create(MyWidgetInjector.class);

  public void onModuleLoad() {
    MyWidgetMainPanel mainPanel = injector.getMainPanel();
    RootPanel.get().add(mainPanel);
  }
}
}}}