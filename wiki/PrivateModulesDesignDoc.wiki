#summary Overview of how private modules are handled within Gin

= Introduction =

Supporting private modules required reworking a large portion of the Gin internals in order to support a hierarchical collection of bindings.  Specifically, installing a new private module creates a new collection of bindings that is a child of the current collection.

In addition to the changes necessary to support the hierarchical binding collections, the process for creating all of the implicit bindings had to be changed significantly in order to determine in which binding collection each implicit binding should be placed.

This document summarizes the changes that had to be made to Gin, and attempts to explain the algorithm for creating and positioning the implicit bindings (reification).

= Changes throughout Gin =

  * Split out the code for storing bindings from `BindingProcessor` into `GinjectorBindings`
  * Modify `GinjectorBindings` to be hierarchical
    * `GinjectorGenerator` had to be updated to produce code for all `GinjectorBindings` in the hierarchy.
    * `ParentBinding` and `ChildBinding` were added to the types of bindings, to support inheriting a binding from a parent and receiving an exposed binding from a child, respectively.
    * Many files were changed to respect the new hierarchical bindings.
  * Create a `BindingResolver` that performs reification.  Initial version used a tree-based algorithm that failed horribly when cycles were present.  The algorithm documented here is version 2, which deals much more gracefully with cycles.
  * Create a class `Dependency` for representing dependencies between types (eg Foo -> Bar)
    * Modify the codebase to return `Set<Dependency>` instead of `Set<Key<?>>` any places dependencies were managed, and correctly set the optional/lazy bits.

= Reification =

The reification process is roughly responsible for making Gin injectors behave similarly to Guice injectors.  The process by which Guice resolves each binding is documented [http://code.google.com/p/google-guice/wiki/BindingResolution here].  Unfortunately, since Gin has to produce the code for the Ginjector at compile time it is not possible to use an identical process to Guice.

To accomplish similar behavior, we satisfy dependencies for each injector according to the following:
  # If a child injector needs a binding that a parent has available, the child will use the parent's binding.
  # If an injector needs a binding that isn't already available to it, it will cause the binding to be created, and positioned as high as possible subject to the following constraints:
    * All of the bindings that it depends on are available (either at or above the ginjector)
    * There is not already a binding for that key at any of the child injectors.

There are several observations about the above process that are important to make.  The most important is that the order of the visiting the ginjectors for reification does not matter.  Since we always place things as high as possible, and the only thing that constrains positions initially is the pre-existing bindings, it is impossible for any decisions we make to affect future positions.

Furthermore, reifying the bindings in a given injector will only add bindings to that injector and higher (closer to the root of the hierarchy).

== Details ==

The reification algorithm occurs in several stages, split up into a variety of classes.

=== DependencyExplorer ===
Starting with the unresolved dependencies in the ginjector, this explores the dependency graph.  For each key that is depended on, this checks to see if it is already available to the ginjector (in which case it reports it as "already available").  Otherwise, it attempts to instantiate it using `ImplicitBindingCreator`.  If that works, it then recursively visits the dependencies of the implicit binding.  If it fails to create an implicit binding, this stores the error for later reporting.

=== UnresolvedBindingValidator ===
This step checks to make sure that a solution exists.  It uses `EagerCycleFinder` to check for eager cycles (cycles that do not pass through lazy edges, such as `Provider`, `AsyncProvider` or a `Factory`).  It also checks for implicit bindings that couldn't be created, as well as bindings that won't be positionable (the key is already bound in a child of the ginjector).  It reports any errors in required keys, and removes all optional bindings that can't be satisifed.

If an error is detected, it will use `PathFinder` to compute the shortest path explaining why that key was deemed necessary, and report that in addition to the error.  The later passes (`BindingPositioner` and `BindingInstaller`) are only run if there were no errors while reifying required keys.

=== BindingPositioner ===
At this point we know a solution exists, so this step determines where each binding should be placed.  It creates an initial "guess" that has each implicit binding positioned as high as possible without creating a double binding (satisfying the 2nd constraint above) and each pre-existing binding placed in the appropriate ginjector.  It then iterates to fix-point, moving each key down to the lowest of all its dependencies.

This pass assumes that a solution exists, because it will not get called if there are any errors reported by `UnresolvedBindingValidator`.

=== BindingInstaller ===
This pass is responsible for installing all of the implicit bindings into the positions specified by BindingPositioner.  If it adds a binding to a parent and its needed in a child, this will also install a special `ParentBinding`, that will instruct the `GinjectorGenerator` to output the code necessary to allow the child to access the parents binding.