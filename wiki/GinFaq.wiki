#summary GIN frequently asked questions
#labels Featured


= GIN frequently asked questions =

== How does GIN work? ==

GIN uses [http://code.google.com/p/google-guice Guice] at compile-time via a [http://google-web-toolkit.googlecode.com/svn/javadoc/1.5/com/google/gwt/core/ext/Generator.html GWT Generator]. The generator creates an implementation of your `Ginjector` interfaces.

== Does GIN have runtime overhead? ==

No, it shouldn't -- it essentially generates the exact code you'd use if you did the dependency injection and object construction by hand. You can look for yourself by compiling your GWT application with `PRETTY` mode and looking at the JavaScript.

== What bindings don't work? ==

Because your Module class is actually executed at _compile_ time, you have to make sure its `configure(...)` method does not execute any GWT client-side code directly. And thus, you also can't carry along any object instances from the Module in to the eventual client code. So, these don't work:

  * `.toInstance(obj)`, because `obj` exists at compile-time, not run-time
  * `.toProvider(new Provider<T>() { ... }`, for the same reason but now because the provider does not exist at run-time. You can fix this case by making the provider a public concrete class in `.client`.

While this does:
{{{
class MyModule extends AbstractGinModule {
  @Override
  protected void configure() {
    bind(Something.class).to(SomethingProvider.class);
  }

  static class SomethingProvider implements Provider<Something> {
    public Something get() {
      return new Something(getDataFromJavaScript());
    }

    // Using JSNI in a provider
    private native String getDataFromJavaScript() /*-{
      ...
    }-*/;
  }
}
}}}

Note that you will not be able to reuse your `GinModule` on the server side (using `GinModuleAdapter`) if your bindings directly or indirectly make use of GWT specific infrastructure like `GWT.create(...)`, widgets or JSNI.